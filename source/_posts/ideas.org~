
Simple F# Unit Test Mocking

If you are writing much F#, you possibly are curious how you might handle unit test mocking. In a language like C# or Java, the common method is to a DI container or handmade constructor injection. These "entry points" allow for a unit test to replace a real dependency with a test-only replacement. 

I previously posted an example that shows a much simpler way to inject dependencies that allows much less code with equivalent safety. The "SimpleMock" pattern can also be used in F#, but it isn't always necessary if you are not using classes. F# has a much simpler way to allow for dependency injection via currying.

Here is a sample program that does some work and persists the results.

``` fsharp
let addAndSave x y =
  let sum = x + y
  DBModule.saveSum sum
  sum
``` 

To test this, we can use currying to simply replace the DBModule.saveSum function with a test-only version. 


``` fsharp
let addAndSave = addAndSave' DBModule.saveSum
let addAndSave' saveSum x y = 
  let sum = x + y
  saveSum sum
  sum

// Test code
let addAndSave_Test =
  let mutable ref calledVar = 0
  let result = addAndSave' (fun sum -> calledVar <- sum) 1 2
  Assert.AreEqual(3, result)
  Assert.AreEqual(3, calledVar)
``` 
We start by renaming the addAndSave function with a trailing ```'```. Then a new ```addAndSave``` is created that calls ```addAndSave'``` with the correct dependency.

The replacement for DBModule.saveSum is fairly complex, but it should be easy to make a simple helper that takes parameters and returns them when called.

``` fsharp
let makeTestFakeOne one = (fun () -> one)
```

With this we can re-write the previous test:

``` fsharp
// Test code
let addAndSave_Test =
  let fakeSaver = makeTestFakeOne
  let result = addAndSave' fakeSaver 1 2
  Assert.AreEqual(3, result)
  Assert.AreEqual(3, fakeSaver())
``` 


* Safety Score
** Exceptions (checked, unchecked)
** variable shadowing 
