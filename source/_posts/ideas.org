# Simple F# Unit Test Mocking

If you are considering using F#, you might be curious how to handle unit test mocking, especially if you want to use both modules and classes. In a language like C# or Java, the common method is to a DI container or handmade constructor injection on a class. These "entry points" allow for a unit test to replace a real dependency with a test-only replacement. 

I previously posted an example that shows a much simpler way to inject dependencies called the SimpleMock pattern. The SimpleMock pattern can also be used in F#, even if you are only using modules.

## SimpleMock in F# Modules

Here is a sample program that does some work and persists the results. We will assume you are mocking inside a module and not a class. Mocking inside an F# class would look much the same as it does in C#, which we showed earlier.

``` fsharp
let addAndSave x y =
  let sum = x + y
  DBModule.saveSum sum
  sum
``` 

To apply the SimpleMock pattern, we can use argument currying. 

``` fsharp
// Integer -> Integer -> Integer
let addAndSave = addAndSave' DBModule.saveSum
// (Integer -> unit) -> Integer -> Integer -> Integer
let addAndSave' saveSum x y = 
  let sum = x + y
  saveSum sum
  sum

// Test code
let addAndSave_Test =
  let mutable ref calledVar : object = 0
  let result = addAndSave' (fun sum:Integer -> calledVar <- sum) 1 2
  Assert.AreEqual(3, result)
  Assert.AreEqual(3, calledVar)
``` 

We started by renaming the ```addAndSave``` function with a trailing ```'```. We created a new ```addAndSave``` that calls ```addAndSave'``` with the correct dependency for the first argument, leaving the rest of the arguments to be called later. Currying is what allows this ability. The new ```addAndSave``` function only needs the ```x``` and ```y``` parameters. At test time, we called ```addAndSave'```, passing in the needed dependency, but using a lambda as the "fake". The injection is as close to the dependency use as possible!

## Bonus: SimpleMock Fake Helper

The earlier replacement for DBModule.saveSum is a bit complex, and it doesn't show us how many times the fake was called. We can easily make a helper that takes parameters and returns them when called, along withe count of times it was called.

``` fsharp
type TestFakeResults() = 
  member val timesCalled:Integer = 0
  member val args: object list = []

let makeFake_OneArg () = 
  let ref results = new TestFakeResults()
  let fake = (fun p1 -> 
                  results.args <- p1 :: args
                  results.timesCalled <- timesCalled + 1
                  p1)
  (fake, results) 
```

The above code might be hard to comprehend at first! We have made a generic helper that can create any single argument fake we need. We return a tuple, containing the fake lambda and an instance of ```TestFakeResults```. The fake lambda will populate the ```TestFakeResults```, which we can access in the test via the second arg of the tuple. 

We can now re-write the previous test using ```makeFake_OneArg```:

``` fsharp
// Test code
let addAndSave_Test =
  let (fakeSave, fakeSaveCalling) = makeFake_OneArg()
  let result = addAndSave' fakeSave 1 2
  Assert.AreEqual(3, result)
  Assert.AreEqual(3, fakeSaveCalling.args[0])
  Assert.AreEqual(1, fakeSaveCalling.timesCalled)
``` 

The TestFakeResults can return information about the way it was called, including the list of all arguments. If we felt we needed the extra expressiveness, we could also use a mocking library like RhinoMocks or Moq. The TestFakeResults and its constructor are not essential to the pattern. The most important part is learning to unit test in F# with confidance.


* Safety Score
** Exceptions (checked, unchecked)
** variable shadowing 
