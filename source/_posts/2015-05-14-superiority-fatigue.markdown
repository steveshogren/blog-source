---
layout: post
title: "Superiority Fatigue"
date: 2015-05-14 19:13
comments: true
categories: 
---

<!-- This post started as a bitter screed against developers who actively and -->
<!-- detrimentally resist new technology. Part way through writing it, I realized I -->
<!-- was entirely trying to vindicate myself, to argue with the people who previously -->
<!-- and currently actively work to entrench us in less productive tooling. -->

Learning new tools, technologies, and methodologies is exhausting. Often times
the most exhausting part is after you've gotten a good comprehension of the
tool, and now, filled with excitement, you try to explain it to someone else.

They react with hostility.

What is going on? You just took time to learn this exciting tool that could save
you a lot of time, and not only do they not care, but they resent you for it!
Don't they see how this could be great for everyone?

The issue, like humans, is complex and dynamic. Maybe they feel like you've now
made them look lazy in comparison. Maybe they have tried new tools in the past
only to discover they weren't as a good as promised. Maybe they are afraid they
won't be able to learn the new tool as quickly as they need to, and will be left
behind. Maybe they are afraid all the time they spent learning the existing
tools will have been wasted. Maybe they are comfortable where they are, and
don't care about increased productivity. Most times I have seen this, I think
the root emotion is fear. Fear of failure, of being embarrassed, of looking
inferior.

Fear is a powerful emotion.

When you react back with hostility, this only will compound their fear. Should
they put their comfort and ego before the needs of the business? No, but you
attacking them will only further prove to them that their fear was accurate.

The hardest part of learning a new tool is when you are forced at work to use an
inferior tool. Suddenly that liberating fresh air of power is replaced with a
suffocating claustrophobia of weakness. Even if the tool isn't really that
inferior, it now _feels_ terrible. It becomes worse when you and many others
around you agree with the better value proposition of a new tool, and yet you
are still required to use the inferior tool due to someone in power blocking you
for political reasons.

While there is always a place for the right tool, sometimes the weakness of
others demands you use the inferior tool.

I've definitely been guilty of suggesting a tool that was actually
only a minor improvement. 







I love programming languages. I love thinking about how and why they work the
way they do. Nothing excites me like finding a new way to squeeze out a little
more productivity or safety from a language. But from my very first interaction with
other team-members, I encountered an opposite type of programmer that surprises
me to this day: the Language Luddite.




### Language Luddites

Language Luddites know one or two languages well, and are certain "their" language is
the best. They may have dabbled in a few others, but will not have learned
enough to accurately compare and contrast the merits of each. Their complaints
against other languages will either be superficial (I hate s-expressions), or
rooted firmly in ignorance (you can't build serious/fast/safe/enterprise systems
in _P_)

### Argument of Self-Knowing

A Language Luddite will defend "their" language as the most superior choice,
regardless of any evidence to the contrary. They will also refuse to learn anything
new, falling for the fallacy of "argument of self-knowing":

    If _P_ were true then I would know it; in fact I do not know it; therefore
    _P_ cannot be true.

Or, read for developers:

    If _P_ were a superior tool then I or my heroes would know it; in fact we do
    not know it; therefore _P_ cannot be superior.

Or, even more commonly:

    If _P_ were a superior tool then I or my heroes would know it; in fact I do
    not know it, and my heroes can't always be right; therefore _P_ cannot be
    superior.

Countless words have been spilled over superior technologies that exist, and
likewise countless words over the wisdom of holding fast to an existing
technology.

### Argument From Ignorance

The argument from ignorance is another common developer fallacy:

    There is no evidence for _P_. Therefore, not-_P_.

For developers

    I have not seen proof you can build serious/fast/safe/enterprise systems in
    _P_. Therefore, it cannot be done.

In the many times I have seen discussions proposed around the adoption of new
technologies or frameworks, they are almost always met with the Language
Adoption Paradox. The Language Adoption Paradox is as follows: "We cannot
consider adopting _P_ unless you prove its value. We will not spend any effort
learning _P_ to disprove its value; the burden of proof is on you. We also
cannot risk allowing you to attempt to prove the value of _P_ for adoption,
because it is unproven." Thus stonewalling any discussion or assessment
entirely.

I have decided that forcing the Language Adoption Paradox on another is
completely selfish. It dresses up fear and ignorance under the banner of
practicality. It incorrectly assumes the worst about people: they are too stupid
to learn new things quickly, new hires will be difficult, training is
impossible. It also incorrectly assumes the best about people: that they are
"good enough" to not need better tools or they are already using the best
tools.

I much prefer the mindset that tools are just tools, and can be assessed
separate from the ego of those adopting them. I believe that better tools exist
than what I am using right now, and that in every situation there exist tools
that I could adopt immediately that would allow me to produce more value than I
currently do. Philosophically, this assumes the best about people in a way I
think is more accurate: humans are extremely quick learners capable of
comprehending new concepts rapidly, hiring for a better tool will open access to
a smaller pool of more skilled developers who prefer to be as productive as
possible, and training is easy. I also assume the worst about people when it
comes to things humans are bad at: getting lots of small details repeatedly
correct.

Looking at the advancements in language design over the last thirty years shows
a distinct trend that reducing complexity by allowing the machine to take on the
management of details allows much more productivity. Simply observing the
history of languages should tell the observer that we are not done yet. There is
more that that machine can do for us, freeing our minds to focus on better
interactions, better abstractions, and better software.
