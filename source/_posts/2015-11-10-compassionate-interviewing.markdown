---
layout: post
title: "Design A Compassionate Interview"
date: 2015-11-10 17:01:58 -0500
comments: true
categories: 
- Meta Game
published: true
---

After my post [Interview Humiliation](http://deliberate-software.com/on-defeat/), a number of
people have asked me how I interview compassionately. I certainly do not claim
to be an expert at the topic, but I strive to make my interviews as
stress-free and respectful as possible.

Any good interview process needs to start with good goals:

  * The candidate should learn as much as possible about working here, good and bad
  * Respect the candidate's time
  * Make the candidate comfortable
  * Under-skilled candidates should feel no shame
  * Both passing and failing candidates should leave wishing they could work here
  * We should render the same decision if the interview is repeated multiple times
  * A "bad day" shouldn't affect the decision
  * Candidate should feel we are working "side-by-side" instead of "face-to-face"

## The Ideal Candidate

I want to hire for high-level skills. Skills like fast learning, strategic
thinking, and emotional intelligence. I care more about "ability to grow" than
"current skills". My job does not involve whiteboard coding, puzzle questions,
or anything that can be discovered with a decent IDE, so those are left out.

I do not care about any question that could be easily be answered by Google. If
an internet search can easily answer the question, it is pointless to care if
the human in front of me happens to know it. Given the search revolution of the
last decade, the value of memorized facts falls to almost zero. 

I'd love to believe that a perfect scoring system can be invented.
Unfortunately, developer productivity needs to be solved first. Without a useful
developer productivity metric, no useful interviewing scoring system can be
made. Counting bugs, features, correct answers, etc, are all proxies that poorly
represent actually productivity. If those actually worked, why don't we use them
for raises, bonuses, and reviews? Because. They. Do. Not. Work.

## Our Process

On reflection of our goals and desired candidate, we came up with the following
process:

* Phone Screen

  We pair program over the internet using a shared programming environment
  called [Cloud9](c9.io). We have projects set up for Java, Javascript, Python,
  Ruby, and C#. The candidate may choose their desired language. We then pair
  program using Test Driven Development to build out a well defined exercise.
  The candidate may entirely verbally "navigate", while one of our programmers
  entirely "drives" and types out the code. This is acceptable. The ideal
  candidate will be able to demonstrate comfort with programming concepts and
  abstraction design.

  Most programmers will have not seen Test Driven Development, and as such will
  have to "learn" it while we work on the project. This is acceptable. If the
  candidate has never seen any of those languages, Google or asking the
  interviewer is totally fair game, and does not count against them. If the
  candidate has completely no idea, the interviewer is expected to complete the
  task while keeping the candidate engaged.

  The phone screen is under an hour, with 30 minutes for the pair programming,
  and any remaining time for questions about our office. We let them drive the
  second half of the interview, asking us questions about what our team and
  process is like. We attempt to answer clearly and honestly, both good and bad.

  To "level-set" our expectations, we had several of our developers at different
  levels perform the interview live in front of the team. We made them use
  various languages and exercises they had never seen before. This
  "level-setting" helped us to see how known good candidates perform when way
  out of their element and uncomfortable. 

* In-Person

  At the start of the day, we spend 30 minutes chatting and asking questions
  back and forth. Our questions are meant to tell us about the candidate's
  background and "programming philosophy": books read, favorite languages,
  interesting projects they've worked on, etc. 

  The rest of the day is very much like a "typical day at work", but with
  programming exercises instead of production code. We pair program on the
  exercises, following the same idea from the phone screen. The exercises have
  no "tricks", they are reasonably straightforward and don't require any prior
  domain or CS theory knowledge. The candidate may pick their preferred language
  and environment (we have several pre-setup). We pair like that all day, with a
  break for lunch. Throughout the day, the candidate is free to get food,
  drinks, and run to the restroom.

  The developer who is pairing has a primary role of making the candidate feel
  comfortable and accomplish the exercises with a 50/50 split of effort. If the
  candidate really is struggling, the developer is expected to keep working with
  the candidate, even to the point of doing the hard parts and giving them the
  easy parts. A completely unskilled candidate will see their pair doing all the
  work with a smile and politely asking for "help" with variable names and such.

  We feel this gives us a highly accurate understanding of a candidate's skill,
  while still putting them at ease. Many times we've seen a terrified candidate
  "come out of their shell" fifteen minutes into a pairing session while
  watching the developer pair do most of the work. Something about seeing code
  written "bootstraps" even the most nervous candidate. All the thoughts of
  nerves turn into a concrete "oh, wait, I know what he just did, I've got an
  opinion on that!"

  We like this process because it is exactly what our job is like. We pair
  program for a lot of work, and this interaction is meant to really drive that
  point home. No one should show up for their first day of work and say, "wait,
  I actually hate pair programming."







